My friend and i are going to make a simple web game called polygon with the theme of survival/tower defense. Create me the inital files and structure. Also     
  create a GameDescription.md file with the necessary information.

  Game Description and System Specification

  This game is a modular, highly configurable 2D action­–tower-defense hybrid built with Phaser for real-time gameplay, React for menus and interface screens,    
  and FastAPI for account management, cloud saves, and progression persistence. The entire project is structured so that every component—players, attacks,        
  enemies, bosses, maps, waves, upgrades—can be created, modified, or extended without rewriting core systems.

  The game revolves around a polygon-shaped player character who can rotate to face the mouse cursor and fire multiple types of attacks. The player progresses    
  through increasingly difficult waves of geometrical enemies, earns points, selects upgrades, and eventually encounters bosses. Progress is autosaved after      
  each wave, including upgrade selections, to prevent forced reroll exploitation. The game can eventually be wrapped for release on Steam.

  Frontend Architecture

  The frontend consists of two core layers: the React UI and the Phaser game engine. The React layer handles all non-gameplay screens including login,
  registration, menus, settings, wave completion screens, and upgrade selection interfaces. Phaser runs the actual gameplay session inside a React component      
  that mounts the game canvas.

  Internally, the Phaser portion is structured into modular subsystems. A core directory contains the game manager, event bus, global configuration, and utility  
  functions. The entities directory contains conceptual game actors such as the player, enemies, bosses, and projectiles, each implemented as a class with        
  extensible behavior. Additional systems handle spawning, wave logic, upgrades, collisions, map generation, and attack execution. A data directory contains      
  JSON configuration files defining enemies, upgrades, player polygon shapes, maps, and bosses.

  Everything in the frontend gameplay layer is designed around configuration and modularity, enabling new content to be created with simple JSON definitions      
  rather than hard-coded logic.

  Player System

  The player is represented as a dynamically rendered geometric polygon. The number of sides is variable and can be changed through upgrades or progression,      
  with each polygon type having corresponding gameplay properties. The polygon has a designated "head" vertex that always rotates to face the mouse cursor. This  
  rotation is updated continuously based on pointer movement.

  The player has a persistent set of combat attributes, including health, movement speed, fire rates per attack type, damage multipliers, polygon-sidedness, and  
  lists of unlocked attack types. These values are stored in a structured dictionary that the game can serialize and save through the backend.

  Polygon rendering is handled through the Phaser Graphics API. Vertices are generated mathematically using angular divisions around the center point, and the    
  head vertex is identified as vertex zero. Rotation logic derives from the angle between the player’s location and the mouse position.

  Attack System

  The attack system is fully modular, with each attack type implemented as its own class under a shared interface. The following attack classes exist in the      
  initial design:

  Bullet
  A projectile that travels with a linear velocity, affected by upgrades that modify speed, damage, size, cooldown, spread, and multi-shot capabilities.

  Laser
  An instant-hit beam implemented using raycasting. It has a longer cooldown but high damage potential and the ability to pierce multiple targets. Its
  properties—pierce count, thickness, damage, cooldown—are defined in configuration.

  Zapper
  A chain-lightning attack. After the initial hit, it automatically seeks nearby targets, applying diminishing damage per jump. The number of chain jumps,        
  damage falloff, and range are configurable.

  Flamer
  A close-range cone-based attack that applies continuous damage while enemies remain within the cone. Damage decreases with distance, and the behavior can be    
  enhanced through range, burn, or damage-over-time upgrades.

  Spinner
  Temporarily rotates the player polygon around its center at high speed. Enemies within a radius take periodic damage, with hit count scaling with the number    
  of polygon sides.

  Attack parameters are adjustable through external configuration files and upgrades, making new attack types easy to add.

  Enemy System

  Enemies are represented as geometric shapes similar to the player but with simpler behavior. Each enemy type is defined in JSON, specifying the number of       
  sides, base health, movement speed, abilities, color, and score reward. The implementation loads these definitions and instantiates enemy objects accordingly.  

  Each enemy type can have unique abilities, implemented as modular ability modules. Examples include dashing forward at intervals, exploding on death, firing    
  projectiles, or splitting into multiple smaller shapes. These abilities are stored in a dedicated abilities directory and can be reused or attached to
  different enemy types via configuration.

  Enemy logic includes movement patterns toward the player, collision handling, taking damage, and death behaviors. All of this is designed to be extensible      
  through subclassing and configuration.

  Boss System

  Bosses appear every tenth wave and are defined similarly to enemies but include multi-phase health thresholds, attack patterns, and larger-scale behaviors.
  Boss data is stored in a bosses.json file. Boss fights are meant to significantly vary gameplay, requiring additional attack avoidance and strategic
  positioning.

  Map and Environment System

  The map is generated procedurally using seeded randomness to ensure reproducibility. The generator produces obstacles, spawn locations, paths, and
  environmental features based on biome configuration files. Obstacles are polygonal or circular colliders that block player and enemy movement.

  Different map “biomes” or themes define obstacle density, color palettes, ambient effects, and enemy spawn biases. These definitions allow the creation of      
  many maps without rewriting logic.

  The procedural map generator is responsible for spawning obstacles outside a safe radius around the player and ensuring that the overall layout is walkable.    

  Wave System

  Gameplay is divided into waves. At the start of each wave, enemies spawn according to a difficulty scaling algorithm. Enemy stats, spawn frequency, and
  quantity increase with wave number. Difficulty can also scale by modifying enemy types, behaviors, or adding special waves.

  When all enemies are eliminated, the wave ends. The player receives points based on performance, and an upgrade selection screen appears through the React UI.  
  Prime-numbered waves grant double score. Every tenth wave is a boss encounter.

  Wave transitions involve saving progress to the backend. This prevents players from circumventing upgrade randomness by reloading the game.

  Upgrade System

  Upgrades are defined as JSON objects specifying rarity, affected stat, magnitude, attack type (if relevant), cost, and whether they stack. After each wave,     
  the player is presented with three randomly selected upgrades filtered by rarity and progression. They may reroll the selection using points.

  Selecting an upgrade immediately applies its effect to the player's stats or unlocked abilities. This data is saved to the backend as part of the autosave      
  routine.

  The system is entirely data-driven, enabling easy creation of new upgrades or balancing through configuration files.

  Backend System (FastAPI)

  The backend handles account services, authentication, cloud saves, and persistent progression. It provides endpoints for registering users, logging in,
  loading saved games, saving progress, and recording wave results.

  Game state data includes the current wave, player statistics, unlocked upgrades, points, seed values, and timestamp. All game states are tied to user
  accounts, enabling players to resume progress seamlessly.

  The backend ensures that save operations after wave completions are atomic and tamper-resistant.

  React Integration

  React provides all non-gameplay scenes and overlays. The main pages include login, registration, main menu, settings, game screen, wave-complete screens,       
  upgrade selection modals, and leaderboards.

  Phaser is embedded inside a React component representing the gameplay area. During wave transitions, React overlays appear while the Phaser scene is paused.    
  All UI is styled using Tailwind for clarity and rapid development.

  Brief bullet points:
  Polygon Player - Triangle shape - Shoots attacks out of corners - has a “head” point which rotates to face the direction mouse cursor - can upgrade to
  different polygons Enemies - spawn during waves - can damage the player - enemies are other shapes with customizable abilities Map - spawns enemies -
  different obstacles - procedurally generated? waves - increase in difficulty - give player some points after each round - allows for a selection of 3 upgrades  
  between rounds. Can be rerolled for points - automatically saves progress when each round ends (so they can re-roll upgrades they dont want) - Boss every       
  10th wave - Prime number waves are double score upgrades - after each round - cost points depending on their quality - random - increase players performance -  
  automatically saves progress when each round ends (so they cant re-roll upgrades they dont want) Player Attacks - Bullet: typical single shot projectile with   
  velocity. Has extremely dynamic upgrade capabilities. - Laser: slower firing, instant-traveling shot that can pierce with insane upgrading capabilities. -      
  Zapper: lightning attack that does chain damage with decreasing damage on each hit. - Flamer: close range, crowd control that can burn with damage depleting    
  over range. - Spinner: spins the polygon to do damage in close proximity, with the number of enemies hit dependent on the number of sides of the polygon. Code  
  requirements - frontend/phaser + react (also maybe tailwind if thats better?) - backend/python + fastapi - everything is HEAVILY modularized… so we can
  easily edit and create new enemies, players, bosses, maps, obstacles, upgrades, etc. 